执行者取消一个任务

当你使用执行者工作时，你不得不管理线程。你只实现Runnable或 Callable任务和把它们提交给执行者。执行者负责创建线程，
在线程池中管理它们，当它们不需要时，结束它们。有时候，你想要取消已经提交给执行者 的任务。在这种情况下，你可以使
用Future的cancel()方法，它允许你做取消操作。

当你想要取消你已提交给执行者的任务，使用Future接口的cancel()方法。根据cancel()方法参数和任务的状态不同，这个方法的行为将不同：

    如果这个任务已经完成或之前的已被取消或由于其他原因不能被取消，那么这个方法将会返回false并且这个任务不会被取消。
    如果这个任务正在等待执行者获取执行它的线程，那么这个任务将被取消而且不会开始它的执行。如果这个任务已经正在运行，
    则视方法的参数情况而定。 cancel()方法接收一个Boolean值参数。如果参数为true并且任务正在运行，那么这个任务将被取消。
    如果参数为false并且任务正在运行，那么这个任务将不会被取消。

如果你使用Future对象的get()方法来控制一个已被取消的任务，这个get()方法将抛出CancellationException异常。


本示例的任务之所以能取消，确实与Thread.sleep(100)相关，因为Future.cancel()方法，其实是发送一个中断请求，而sleep能够响应中断，
因此能达到取消正在执行任务的目的。也就是说只要执行中的任务能够响应中断，便能通过cancel()方法来取消任务的执行，所以不一定要
用Thread.sleep(100)，诸如对Thread.interrupted()的判断也行。至于jvm性能上的影响，由于没有实践测试过，不敢妄加下定论，但个人觉得，
中断状态也应该只是对一个变量的判断，性能上应该不会有什么影响。如果不想以这种方式取消一个任务，也可以通过一个volatile变量来控制。


