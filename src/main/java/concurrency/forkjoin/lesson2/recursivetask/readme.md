加入任务的结果
===

Fork/Join框架提供了执行返回一个结果的任务的能力。这些任务的类型是实现了RecursiveTask类。这个类继承了ForkJoinTask类和实现了执行者框架提供的Future接口。

在任务中，你必须使用Java API方法推荐的结构：
```
If (problem size < size){
	tasks=Divide(task);
	execute(tasks);
	groupResults()
	return result;
} else {
	resolve problem;
	return result;
}

```
如果这个任务必须解决一个超过预定义大小的问题，你应该将这个任务分解成更多的子任务，并且用Fork/Join框架来执行这些子任务。当这些子任务完成执行，发起的任务将获得所有子任务产生的结果 ，对这些结果进行分组，并返回最终的结果。最终，当在池中执行的发起的任务完成它的执行，你将获取整个问题地最终结果。

本示例中,你将会实现以下两种任务类型：

    一个文档任务，将在文档中的行集合中查找一个单词。
    一个行任务，将在文档的一部分数据中查找一个单词。

所有任务将返回单词在文档的一部分中或行中出现的次数。


## 它是如何工作的…

在这个示例中，你已经实现了两种不同的任务：

    DocumentTask类：这个类的任务将处理由start和end属性决定的文档中的行组。如果这个行组的大小小于10，它为每行创建LineTask对象，并且当它们完成它们的执行时，它合计这些任务的结果，并返回这个合计值。如果这个任务要处理的行组大小不小于10，它将这个组分成两个并创建两个DocumentTask对象来处理这些新组。当这些任务完成它们的执行时，这个任务合计它们的结果，并返回这个合计值。
    LineTask类：这个类的任务将处理文档中的一行的单词组。如果这个单词组小于10，这个任务直接在这个单词组中查找单词，并且返回这个单词出现的次数。否则，它将这个单词组分成两个并创建两个LineTask对象来处理。当这些任务完成它们的执行，这个任务合计这些任务的结果并返回这个合计值。

在Main类中，你已经使用默认构造器一个ForkJoinPool对象，并且你在它里面执行一个DocumentTask类，这个类将处理一个拥有100行，每行有1000个单词的文档。这个任务将使用其他的DocumentTask对象和LineTask对象来分解这个问题，当所有任务完成它们的执行，你可以使用启动任务来获取单词在整个文档中出现的总次数。由于任务返回一个结果，所以它们继承RecursiveTask类。

为了获取Task返回的结果，你已经使用了get()方法 。这个方法是在Future接口中声明的，由RecursiveTask类实现的。

当你执行这个程序，你可以比较在控制台中的第一行和最后一行。第一行是文档生成时计算的单词出现的次数，最后一行是由Fork/Join任务计算的。

## 不止这些…

ForkJoinTask类提供其他的方法来完成一个任务的执行，并返回一个结果，这就是complete()方法。这个方法接收一个RecursiveTask类的参数化类型的对象，并且当join()方法被调用时，将这个对象作为任务的结果返回。 它被推荐使用在：提供异步任务结果。

由于RecursiveTask类实现了Future接口，get()方法其他版本如下：

    get(long timeout, TimeUnit unit)：这个版本的get()方法，如果任务的结果不可用，在指定的时间内等待它。如果超时并且结果不可用，那么这个方法返回null值。TimeUnit类是一个枚举类，它有以下常量：DAYS, HOURS，MICROSECONDS，MILLISECONDS， MINUTES， NANOSECONDS和SECONDS。
