原子数组
==
当你实现一个多个线程共享一个或者多个对象的并发应用时，你就要使用像锁或者同步关键词（例如synchronized）来对他们的属性的访问进行保护，来避免并发造成的数据不一致的错误。

但是这些机制会有以下一些缺点：
死锁(dead lock)：例如：当一个线程等待一个锁的时候，会被阻塞，而这个锁被其他线程占用并且永不释放。这种情况就是死锁，程序在这种情况下永远都不会往下执行。

即使只有一个线程在访问共享对象，它也要执行必要的获取锁和释放锁的代码。

CAS(compare-and-swap)操作为并发操作对象的提供更好的性能，CAS操作通过以下3个步骤来实现对变量值得修改：

    获取当前内存中的变量的值
    用一个新的临时变量(temporal variable)保存改变后的新值
    如果当前内存中的值等于变量的旧值，则将新值赋值到当前变量；否则不进行任何操作

对于这个机制，你不需要使用任何同步机制，这样你就避免了 deadlocks，也获得了更好的性能。这种机制能保证多个并发线程对一个共享变量操作做到最终一致。

Java 在原子类中实现了CAS机制。这些类提供了compareAndSet() 方法；这个方法是CAS操作的实现和其他方法的基础。

Java 中还引入了原子Array，用来实现Integer类型和Long类型数组的操作。


更多…
==

如今，Java仅提供了另一个原子 array类。它是 AtomicLongArray 类，与 IntegerAtomicArray 类提供了相同的方法。

这些类的一些其他有趣的方法有：
get(int i): 返回array中第i个位置上的值
set(int I, int newValue): 设置array中第i个位置上的值为newValue