用优先级对使用阻塞线程安全的列表排序
===

一个典型的需求是，当你需要使用一个有序列表的数据结构时，Java提供的PriorityBlockingQueue类就拥有这种功能。

你想要添加到PriorityBlockingQueue中的所有元素必须实现Comparable接口。这个接口有一个compareTo()方法，它接收同样类型的对象，你有两个比较的对象：一个是执行这个方法的对象，另一个是作为参数接收的对象。如果本地对象小于参数，则该方法返回小于0的数值。如果本地对象大于参数，则该方法返回大于0的数值。如果本地对象等于参数，则该方法返回等于0的数值。

PriorityBlockingQueue使用compareTo()方法决定插入元素的位置。（校注：默认情况下）较大的元素将被放在队列的尾部。

阻塞数据结构（blocking data structure）是PriorityBlockingQueue的另一个重要特性。它有这样的方法，如果它们不能立即进行它们的操作，则阻塞这个线程直到它们的操作可以进行。

##它是如何工作的…

在这个指南中，你已使用PriorityBlockingQueue实现Event对象的一个优先级队列。正如我们在引言中提到的，所有存储在PriorityBlockingQueue的元素必须实现Comparable接口，所以，你已在Event类中实现compareTo()方法。

所有事件都有一个优先级属性。拥有更高优先级的元素将成为队列的第一个元素。当你已实现compareTo()方法，如果执行这个方法的事件拥有比作为参数传入的事件更高的优先级时，它将返回-1。在其他情况下，如果执行这个方法的事件拥有比作为参数传入的事件更低的优先级时，它将返回1。如果这两个对象拥有相同优先级，compareTo()方法将返回0。在这种情况下，PriorityBlockingQueue类并不能保证元素的顺序。

我们已实现Task类来添加Event对象到优先级队列中。每个任务对象使用add()方法往队列添加1000个事件（0到99种优先级）。

##不止这些…

PriorityBlockingQueue类提供其他有趣的方法，以下是其中一些方法的描述：

    clear()：这个方法删除队列中的所有元素。
    take()：这个方法返回并删除队列中的第一个元素。如果队列是空的，这个方法将阻塞线程直到队列有元素。
    put(E e)：E是用来参数化PriorityBlockingQueue类的类。这个方法将作为参数传入的元素插入到队列中。
    peek()：这个方法返回列队的第一个元素，但不删除它。
