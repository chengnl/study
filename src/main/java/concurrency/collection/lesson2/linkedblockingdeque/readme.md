使用阻塞线程安全的列表
==

列表（list）是最基本的集合。一个列表中的元素数量是不确定的，并且你可以添加、读取和删除任意位置上的元素。并发列表允许不同的线程在同一时刻对列表里的元素进行添加或删除，而不会产生任何数据不一致的问题。

在这个指南中，你将学习如何在你的并发应用程序中使用阻塞的列表。阻塞列表与非阻塞列表的主要区别是，阻塞列表有添加和删除元素的方法，如果由于列表已满或为空而导致这些操作不能立即进行，它们将阻塞调用的线程，直到这些操作可以进行。Java包含实现阻塞列表的LinkedBlockingDeque类。

##它是如何工作的…

在这个指南中，你已使用参数化为String类的LinkedBlockingDeque来处理非阻塞并发列表的数据。

Client类使用put()方法添加字符串到列表中。如果列表已满（因为你已使用固定大小来创建它），这个方法阻塞线程的执行，直到列表有可用空间。

Main类使用take()方法从列表中获取字符串，如果列表为空，这个方法将阻塞线程的执行，直到列表中有元素。

在这个例子中，使用LinkedBlockingDeque类的这两个方法，如果它们在阻塞时被中断，将抛出InterruptedException异常。所以，你必须包含必要的代码来捕捉这个异常。

##不止这些…

LinkedBlockingDeque类同时提供方法用于添加和获取列表的元素，而不被阻塞，或抛出异常，或返回null值。这些方法是：

    takeFirst() 和takeLast()：这些方法分别返回列表的第一个和最后一个元素。它们从列表删除返回的元素。如果列表为空，这些方法将阻塞线程，直到列表有元素。
    getFirst() 和getLast()：这些方法分别返回列表的第一个和最后一个元素。它们不会从列表删除返回的元素。如果列表为空，这些方法将抛出NoSuchElementExcpetion异常。
    peek()、peekFirst(),和peekLast()：这些方法分别返回列表的第一个和最后一个元素。它们不会从列表删除返回的元素。如果列表为空，这些方法将返回null值。
    poll()、pollFirst()和 pollLast()：这些方法分别返回列表的第一个和最后一个元素。它们从列表删除返回的元素。如果列表为空，这些方法将返回null值。
    add()、 addFirst()、addLast()：这些方法分别在第一个位置和最后一个位置上添加元素。如果列表已满（你已使用固定大小创建它），这些方法将抛出IllegalStateException异常。
    
    
    
**通过ReentrantLock的condition锁实现阻塞队列特性.**