Fork/Join框架 4
====

##引言

通常，当你实现一个简单的并发应用程序，你实现一些Runnable对象和相应的 Thread对象。在你的程序中，你控制这些线程的创建、执行和状态。Java 5引入了Executor和ExecutorService接口及其实现类进行了改进（比如：ThreadPoolExecutor类）。

执行者框架将任务的创建与执行分离。有了它，你只要实现Runnable对象和使用Executor对象。你提交Runnable任务给执行者，它创建、管理线程来执行这些任务。

Java 7更进一步，包括一个面向特定问题的ExecutorService接口的额外实现，它就是Fork/Join框架。

这个框架被设计用来解决可以使用分而治之技术将任务分解成更小的问题。在一个任务中，检查你想要解决问题的大小，如果它大于一个既定的大小，把它分解成更小的任务，然后用这个框架来执行。如果问题的大小是小于既定的大小，你直接在任务中解决这问题。它返回一个可选地结果。

没有公式来确定问题的参数大小，所以你可以根据它的特点来确定一个任务是否可以被细分。你可以参考任务处理元素的大小和预估任务执行时间来确定子任务大小。你需要解决的问题是测试不同的参考大小来选择最好的一个。你可以将ForkJoinPool作为一种特殊的执行者来考虑。

这个框架基于以下两种操作：

    fork操作：当你把任务分成更小的任务和使用这个框架执行它们。
    join操作：当一个任务等待它创建的任务的结束。

Fork/Join 和Executor框架主要的区别是work-stealing算法。不像Executor框架，当一个任务正在等待它使用join操作创建的子任务的结 束时，执行这个任务的线程（工作线程）查找其他未被执行的任务并开始它的执行。通过这种方式，线程充分利用它们的运行时间，从而提高了应用程序的性能。

为实现这个目标，Fork/Join框架执行的任务有以下局限性：

    任务只能使用fork()和join()操作，作为同步机制。如果使用其他同步机制，工作线程不能执行其他任务，当它们在同步操作时。比如，在Fork/Join框架中，你使任务进入睡眠，正在执行这个任务的工作线程将不会执行其他任务，在这睡眠期间内。
    任务不应该执行I/O操作，如读或写数据文件。
    任务不能抛出检查异常，它必须包括必要的代码来处理它们。

Fork/Join框架的核心是由以下两个类：

    ForkJoinPool：它实现ExecutorService接口和work-stealing算法。它管理工作线程和提供关于任务的状态和它们执行的信息。
    ForkJoinTask： 它是将在ForkJoinPool中执行的任务的基类。它提供在任务中执行fork()和join()操作的机制，并且这两个方法控制任务的状态。通常， 为了实现你的Fork/Join任务，你将实现两个子类的子类的类：RecursiveAction对于没有返回结果的任务和RecursiveTask 对于返回结果的任务。

 